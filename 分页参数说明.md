# 分页逻辑参数说明

## 概述

本文档详细说明了Google Photos API分页逻辑所需的参数，以及这些参数在protobuf消息中的具体位置。

## 一、分页请求参数

### 1.1 请求参数列表

分页逻辑需要以下参数：

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| `pageToken` | string | 否 | 页面令牌，用于获取下一页数据 |
| `limit` | int | 是 | 每页返回的项目数量 |

**根据抓包发现**: 两次请求之间只有 field 1.4 不同，field 1.4 的值来自上一次响应的 field 1.1。

### 1.2 参数在Protobuf中的位置

#### 请求消息结构

```
请求根消息
└── field 1 (嵌套消息) - 主请求数据
    ├── field 1.1 (嵌套消息) - 媒体元数据选项
    ├── field 1.2 (varint) - limit (页面大小限制)
    ├── field 1.3 (嵌套消息) - 相册和集合选项
    ├── field 1.4 (string) - pageToken (分页令牌，来自上次响应的 field 1.1)
    ├── field 1.7 (varint) - 类型标识 (固定值: 2)
    ├── field 1.11 (repeated varint) - 配置选项 [1, 2]
    └── field 1.22 (嵌套消息) - 其他配置

注意：请求中没有 field 2
```

#### 参数字段详细说明

**1. pageToken - 字段 1.4 (唯一变化的字段)**
- **Protobuf字段**: `field 1.4`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 分页令牌，这是两次请求间唯一不同的字段
- **首次请求**: 为空字符串
- **后续请求**: 使用上一次响应中 `field 1.1` 的值

**2. limit - 字段 1.2**
- **Protobuf字段**: `field 1.2`
- **Wire类型**: 0 (varint)
- **用途**: 限制每页返回的项目数量
- **典型值**: 50
- **注意**: 此字段在所有请求中保持不变

### 1.3 Go代码实现

在 `backend/api.go` 中的 `buildMediaListRequestField1` 函数：

```go
func buildMediaListRequestField1(pageToken string, stateToken string, limit int) []byte {
    var buf bytes.Buffer
    
    // field1.1 - 媒体元数据选项
    mediaMetadataFields := []int{1, 3, 4, 5, 6, 7, 15, 16, 17, 19, 20, 21, 25, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41}
    field1_1 := buildEmptyNestedMessage(mediaMetadataFields)
    writeProtobufField(&buf, 1, field1_1)
    
    // field1.2 - 页面大小限制 (varint)
    if limit > 0 {
        writeProtobufVarint(&buf, 2, int64(limit))
    }
    
    // field1.3 - 相册和集合选项
    albumOptions := []int{2, 3, 7, 8, 14, 16, 17, 18, 19, 20, 21, 22, 23, 27, 29, 30, 31, 32, 34, 37, 38, 39, 41}
    field1_3 := buildEmptyNestedMessage(albumOptions)
    writeProtobufField(&buf, 3, field1_3)
    
    // field1.4 - 分页令牌 (string)
    // 注意：这是两次请求间唯一变化的字段
    // 此字段的值来自上一次响应的 field 1.1
    if pageToken != "" {
        writeProtobufString(&buf, 4, pageToken)
    }
    
    // 注意：实际请求中没有使用 field1.6 (stateToken)
    
    // field1.7 - 类型 (varint = 2)
    writeProtobufVarint(&buf, 7, 2)
    
    // field1.11 - 重复的整数 [1, 2]
    writeProtobufVarint(&buf, 11, 1)
    writeProtobufVarint(&buf, 11, 2)
    
    // field1.22 - 配置
    var field22 bytes.Buffer
    writeProtobufVarint(&field22, 1, 2)
    writeProtobufField(&buf, 22, field22.Bytes())
    
    return buf.Bytes()
}
```

## 二、分页响应参数

### 2.1 响应参数列表

API响应包含以下分页相关参数：

| 参数名 | 类型 | 说明 |
|--------|------|------|
| `items` | []MediaItem | 当前页的媒体项目列表 |
| `field 1.1` | string | 分页令牌，需要在下次请求的 field 1.6 中使用 |

**注意**: 根据抓包分析，响应中的 field 1.1 应该在下次请求时放入 field 1.6。

### 2.2 响应在Protobuf中的位置

#### 响应消息结构

```
响应根消息
└── field 1 (嵌套消息) - 主响应数据
    ├── field 1.1 (string) - 分页令牌 (用于下次请求的 field 1.6)
    ├── field 1.2 (repeated 嵌套消息) - items (媒体项目数组)
    │   └── 每个媒体项目:
    │       ├── field 1 (string/嵌套) - mediaKey (媒体键)
    │       ├── field 2 (嵌套消息) - 元数据
    │       │   └── field 4 (string) - filename (文件名)
    │       ├── field 5 (varint) - mediaType (1=照片, 2=视频)
    │       └── field 4 (嵌套消息) - timestamp (时间戳)
```

#### 响应字段详细说明

**1. items - 字段 1.2 (repeated)**
- **Protobuf字段**: `field 1.2` (repeated)
- **Wire类型**: 2 (length-delimited / nested message)
- **用途**: 包含当前页的所有媒体项目

**2. field 1.1 - 分页令牌**
- **Protobuf字段**: `field 1.1`
- **Wire类型**: 2 (length-delimited / string)
- **用途**: 返回分页令牌，必须在下次请求的 `field 1.6` 中使用
- **特殊情况**: 空字符串或不存在表示已到最后一页

### 2.3 Go代码实现

在 `backend/api.go` 中的 `parseResponseField1` 函数：

```go
func parseResponseField1(data []byte, limit int) ([]MediaItem, string) {
    var items []MediaItem
    var paginationToken string
    
    offset := 0
    for offset < len(data) {
        fieldNum, wireType, newOffset := readTag(data, offset)
        if newOffset < 0 {
            break
        }
        offset = newOffset
        
        switch wireType {
        case 0: // Varint
            _, offset = readVarint(data, offset)
        case 2: // Length-delimited
            length, newOffset := readVarint(data, offset)
            if newOffset < 0 || newOffset+int(length) > len(data) {
                return items, paginationToken
            }
            fieldData := data[newOffset : newOffset+int(length)]
            offset = newOffset + int(length)
            
            // Field 2 包含媒体项目数组 (repeated field)
            if fieldNum == 2 {
                item := tryParseMediaItem(fieldData)
                if item != nil && item.MediaKey != "" && shouldAddItem(len(items), limit) {
                    items = append(items, *item)
                }
            }
            // Field 1 是分页令牌（用于下次请求的 field 1.4）
            if fieldNum == 1 {
                paginationToken = string(fieldData)
            }
        // ... 其他处理
        }
    }
    
    return items, paginationToken
}
```

## 三、分页工作流程

### 3.1 首次请求 (第一页)

**请求参数:**
```
pageToken: ""          (空字符串)
limit: 50              (例如)
```

**Protobuf结构:**
```
field 1:
  field 1.2: 50        (limit)
  field 1.4: ""        (pageToken - 为空或不发送)
```

**Go代码调用:**
```go
result, err := api.GetMediaList("", 50)
```

**API响应:**
```json
{
  "items": [...],           // 媒体项目列表
  "paginationToken": "ABC123"   // 分页令牌 (来自响应的 field 1.1)
}
```

### 3.2 后续请求 (第二页及之后)

**请求参数:**
```
pageToken: "ABC123"    (来自上一次响应的 field 1.1)
limit: 50
```

**Protobuf结构:**
```
field 1:
  field 1.2: 50        (limit)
  field 1.4: "ABC123"  (pageToken - 来自上次响应的 field 1.1)
```

**Go代码调用:**
```go
result, err := api.GetMediaList("ABC123", 50)
```

**API响应:**
```json
{
  "items": [...],                // 新的媒体项目列表
  "paginationToken": "DEF456"    // 新的分页令牌
}
```

### 3.3 最后一页

**API响应:**
```json
{
  "items": [...],              // 最后一批媒体项目
  "paginationToken": ""        // 空字符串或不存在
}
```

**检测逻辑:**
```go
if result.PaginationToken == "" {
    // 已到达最后一页
}
```

## 四、关键注意事项

### 4.1 分页机制

根据抓包分析，分页机制非常简单：
1. **唯一变化的字段**: 请求中只有 field 1.4 会改变
2. **令牌来源**: field 1.4 的值来自上一次响应的 field 1.1
3. **其他字段**: 所有其他字段（包括 field 1.2 的 limit）在请求间保持不变

### 4.2 参数传递

**CLI实现示例:**
```go
var currentPageToken string

// 首次请求
result, err := api.GetMediaList("", pageSize)
currentPageToken = result.PaginationToken

// 后续请求
result, err = api.GetMediaList(currentPageToken, pageSize)
currentPageToken = result.PaginationToken  // 更新分页令牌
```

**前端实现示例:**
```typescript
const pageToken = ref('')

// 首次加载
const result = await backend.GetMediaList('', 50)
pageToken.value = result.paginationToken

// 加载更多
const result = await backend.GetMediaList(pageToken.value, 50)
pageToken.value = result.paginationToken  // 更新分页令牌
```

## 五、实际抓包发现总结

### 5.1 请求结构

根据实际抓包，请求的protobuf结构为：
```
field 1:
  field 1.1: {...}         (元数据选项 - 固定)
  field 1.2: 50            (limit - 固定)
  field 1.3: {...}         (相册选项 - 固定)
  field 1.4: "token"       (唯一变化的字段)
  field 1.7: 2             (类型 - 固定)
  field 1.11: [1, 2]       (配置 - 固定)
  field 1.22: {...}        (其他配置 - 固定)
```

### 5.2 响应结构

根据实际抓包，响应的protobuf结构为：
```
field 1:
  field 1.1: "token"       (分页令牌 - 用于下次请求的 field 1.4)
  field 1.2: [{...}, {...}] (媒体项目数组)
```
    // 内部根据参数自动处理
    // 当 pageToken == "" 时，为首次请求
    // 当 pageToken != "" 时，为后续请求
}
```

## 六、参考资料

### 6.1 相关文件

| 文件 | 说明 |
|------|------|
| `backend/api.go` | API核心实现，包含protobuf构建和解析逻辑 |
| `cli.go` | CLI分页逻辑 |
| `frontend/src/Gallery.vue` | 前端分页实现 |
| `分页修复总结.md` | 分页修复的历史文档 |

## 七、总结

### 分页参数快速参考表

| 参数 | Protobuf位置 (请求) | Protobuf位置 (响应) | 数据类型 | 首次请求 | 后续请求 |
|------|-------------------|-------------------|---------|---------|---------|
| pageToken | field 1.4 | field 1.1 | string | 空 | 使用响应的 field 1.1 |
| limit | field 1.2 | - | varint | 50 | 50 (不变) |
| items | - | field 1.2 (repeated) | nested message[] | - | - |

### 关键要点

1. **唯一变化的字段**: 请求中只有 field 1.4 会改变
2. **令牌传递**: 响应的 field 1.1 → 下次请求的 field 1.4
3. **简单机制**: 不需要 stateToken，只需要一个分页令牌即可
